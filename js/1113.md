# 수업메모
* 다른 라이브러리들과 리액트의 차이점 : ui를 만들어주는 태그들(div, li...등)이 값이다. 
* 리액트는 화면을 그리기 위해 상태를 바꾼다.
* 새 버전의 리액트의 함수형 컴포넌트에 여러 기능이 추가되고있다.
* 예외처리 함수 순서는 try, catch, finally 순으로 쓰면된다.
* 내가 만든 코드를 다른 개발자들이 잘못 사용한다면 직접 에러를 발생시켜야 할 때도 있다. 그럴때는 throw new Error사용
* 나만의 에러 클래스를 만들 수 있으며 에러 인스턴스도 만들 수 있다.
* 에러는 호출스택을 되감는 과정에서 감지될 수 있다.
* 비동기식으로 작동하는 콜백의 내부에서 발생한 에러는, 콜백 바깥에 있는 try 블록으로는 잡아낼 수 없습니다. 비동기 콜백함수에서 try와 catch를 사용하기 위해서는 함수를 try와 catch안에 써줘야한다.
* 비동기 함수인경우 rejected상태의 promise를 await하는 경우에 에러가 발생하면 그 에러는 try, catch를 사용해서 잡아낼 수 있다.

## 리액트
* html에서 사용하던 어트리뷰트를 그대로 쓸 수 없다. 참조 : https://reactjs-org-ko.netlify.com/docs/dom-elements.html
* 리액트에서는 XSS공격을 방지하는 기능이 내장되어있다.
* 순수 DOM요소 객체를 생성하는데는 비용이 많이 든다. ex. document.createElement('p')
* 보통 하나의 사이트를 만들경우에는 하나의 루트DOM 노드를 만들어준다.
* 리액트 엘리먼트 vs 리액트 네이티브(모바일)
* 불변성(immutabilty) : 변경이 불가능하다는 뜻을 가지고 있지만 리액트에서는 값을 변경하고 싶을 때는 값을 새로 만든다.(slice를 이용해 배열을 복사)
* DOM 트리에서 변경된 부분을 개발자 도구에서는 보라색으로 표시해준다.
* 리액트는 이전의 정보를 기억하다가 새로운 정보와 비교해 필요한 업데이트만을 적용한다. 
* 최상위 단위 컴포넌트는 App이라고 이름짓는게 관례이다.
* 부모에게서 받은 props는 수정불가
* 동일한 입력에 대해 항상 동일한 결과를 반환하는 함수를 순수함수라고 불린다.
* 모든 React 컴포넌트는 props에 대해서는 순수 함수처럼 동작해야한다. 
예를들어 render()메소드 안에서 Math.random()과 같은 메소드를 쓰면 안된다. 즉 항상 같은 props에 관해서는 항상 같은 결과를 출력해야 한다.
* 캡슐화 -> 정보를 숨기는 행위 / 상태의 캡슐화 -> 정보가 외부로부터 숨겨져있다.
* 리액트에서는 화면을 다시 그리기위해서는 상태가 필요하다.
* 리액트 컴포넌트의 엘리먼트가 사라지는 순간과 없어지는 순간을 컨트롤 할 수 있다. 이것을 라이프사이클이라고 불리운다. 
* 컴포넌트의 생애주기마다 어떤 특정코드를 실행시키는 방법이 있고 그것을 라이프사이클 훅이라고 부른다.
* setState는 사실 비동기함수다.
* this.props 및 this.state 가 비동기로 업데이트될 수 있기 때문에, 다음 state를 계산할 때 이 값을 신뢰해서는 안된다.
* 다음 상태를 이전 상태로부터 계산하고 싶을때는 setState에는 함수를 넣으면된다.
예:
```js
this.setState((prevState, props) => ({
  counter: prevState.counter + props.increment
}));
```
* 리액트에는 상태 업데이트하기위한 큐가 있다.
* object.assign은 얕은 병합 즉 중첩되었는 배열이 존재할 때 문제가 생긴다. 즉 중첩시키지 않고 병합한 속성의 이름과 속성에 값을 첫번째 인수에 넣게되면 속성이 변형된다.(object.assign은 첫번째 인수에 다른 인수들을 병합시킨다.)
* setState는 얕은복사를 하기 때문에 객체안의 객체나 배열안의 배열은 좋지않다.
* h1, div와 같은 태그 객체들에게만 onClick을 써야 DOM 이벤트리스너로 등록이 된다.
* 리액트에서는 비동기함수를 이벤트 리스너에 등록하는것은 위험하다.
* 이벤트리스너를 리액트에서 사용할때는 주의할것
* event.persist()
* this를 결정할 수 없기 때문에 메소드를 그냥 이벤트리스너를 등록시키면 안된다. 하지만 bind를 호출하거나 화살표함수를 쓰게됨으로써 해결할 수 있다. 그런데 화살표 함수안의 this는 고정되어있기 때문에 화살표 함수를 사용하는것을 추천한다.
* 리액트는 true, false, null은 화면에 그려주지 않는다.
* 리액트에서는 &&, ||, 삼항연산자가 자주 쓰인다.
* 아무것도 그리고싶지 않을 때는 null을 반환하면된다.
