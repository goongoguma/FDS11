# 수업내용 정리

## 제어되지 않는 컴포넌트 (비교조정 피하기부터)
  - input에 onChange를 넣어주는 이유 : 제어되지 않는 컴포넌트로 만들기 위해
  - 원래 html에서는 기본값을 넣어주기 위해 value 어트리뷰트를 사용했지만 리액트에서는 defaultValue(제어되지않는 컴포넌트) 어트리뷰트를 대신 사용한다.
  - html에서는 checkbox와 radio버튼의 상태를 checked로 체크된 상태로 변경이 가능하다. 이와는 반대로 리액트에서는 checked라는 어트리뷰트에 {true}를 넣어줘야한다. (checked = {true}) 하지만 defaultChecked를 넣어주면 제어되지 않는 컴포넌트로 두면서도 체크된 상태를 기본상태로 만들 수 있다.
  - 낙관적 업데이트 vs 비관적 업데이트
  - 성능 최적화는 정말 중요한 부분. 나중에 꼭 다시한번 읽어보기
  - 리액트에서는 상태가 아주 조금 바뀌어도 setState를 호출하면 setState가 일어난 모든 자식 컴포넌트, 엘리먼트들을 다시 호출하기 때문에 큰 앱의 경우 성능상 느려질 수 있다.
  - 그런데 만일 어떤 컴포넌트가 가지고있는 props와 state (두 객체)의 속성이 바뀌지않았다면 화면을 새로 그릴 필요가 없다. 즉, render 매서드를 호출할 필요가 없다. Pure.Component를 사용함으로써 최적화가 가능해진다.
  - 최적화 예시 : https://codesandbox.io/s/64vkzrr9z3
  - Pure.Component
    - Pure.Component를 적용하면, state와 props의 속성이 변경되었을 때만 render 메소드를 호출해서 화면을 새로 그린다. 
    - state나 props에 참조 타입의 값(배열 혹은 객체)이 들어있다면, 배열이나 객체의 내용이 바뀌어도 참조가 바뀌지 않는 한 리액트는 화면을 새로 그리지 않는다. 이럴때는 참조에 slice나 concat 메소드를 써주어서 새로운 배열을 만들면 된다.
    - 참조에 관해 : https://helloworldjavascript.net/pages/220-value-in-depth.html
    - 예시 : https://codesandbox.io/s/mw6r8o5kp
  -  화면을 그리는 과정에서 중복된 단계를 생략하기 위해 Pure.Component를 사용한다. 때문에 화면을 다시 그릴 필요가 있는지 없는지를 다시 검사하기 위해 '비싼 연산'을 사용할 필요가 없다.
  -  불변성 : 내용이 변경되었을 때, 참조 역시 같이 변경이되는것.
  -  불변성, 불변값을 활용하게 되면 '비싼연산'을 할 필요가 없다. (내용이 바뀌었는지를 알기위해서 깊은 비교없이 참조값만 비교가 가능)
  -  정리하면, React.Component를 상속받으면 setState가 호출될 때마다 매번 모든 자식을 호출한다. 하지만 매번 비교하는건 번거롭고 깊은 비교는 비싸기 때문에 리액트 입장에서 참조값을 사용하여 빠르게 비교한다. 그리고 그 역할을 하는 컴포넌트가 Pure.Component이다. 
  -  불변성의 단점 : 매번 새로운 객체나 배열을 생성하므로 메모리 공간을 차지하고 속도도 느려진다.
  -  자바스크립트의 객체와 배열은 원래 가변이기 때문에 불변으로 다루기가 어렵기 때문에 immutable 라이브러리를 사용한다.
    - 예시 : https://repl.it/@goongoguma/immutable?language=javascript
  - 요즘 떠오르는 자바스크립트 불변성 유지 및 생성 관련 라이브러리 : immer (내장배열 사용가능)
  - Pure.Component안에 shouldComponentUpdate가 내장되어있다.
  - shouldComponentUpdate는 props와 state가 업데이트가 되면 true를 반환하는 메소드

## 비교조정
  - 이전에 그렸던것과 다음에 그릴것을 비교해서 수행해야하는것을 비교조정이라고 한다.
  - 알고리즘의 계산속도 O(n^)에 제곱 세제곱은 느린 알고리즘. n이나 logn은 빠른 알고리즘
  - 리액트의 비교과정
    - 엘리먼트 타입, 키(key)를 이용해 비교를 수행하고 이것들이 달라지면 그 아래부분은 더 이상 비교를 수행하지 않고 새로 그린다. (상태가 날아간다)
  - 엘리먼트 타입이 바뀌면 그 안에 있었던 모든 상태가 없어진다. 즉 리액트 상태는 화면에 그려질때만 존재한다.
  - 같은 타입의 DOM 엘리먼트일 경우 리액트가 정보를 수정하는 방법
  - 같은 타입의 컴포넌트 엘리먼트일 경우 리액트가 정보를 수정하는 방법 : 상태는 유지되고 라이프사이클이 호출되며 props가 바뀐다
  - componentWillReceiveProps()는 더 이상 쓰이지 않는다.
  - 같은 자료일경우 키의 값이 바뀌게 되면 리액트는 다른 자료라고 인식하기 때문에 키의 값은 바뀌면 안된다.
  
## 키
  - 상태를 강제로 리셋시키고 라이프사이클 훅을 실행시킬때 사용할 수 있다.
    - 예시 : https://codesandbox.io/s/7mxww787j6
  
* 목, 금 수업을 위해 리액트의 context 개념 읽어오기