# 수업메모
* 함수를 인수로 받거나 함수를 반환하는 함수를 고차함수라고 한다.
* 다른 함수의 인수로 넘겨지는 함수를 콜백이라고 부르기도 한다. 
* 클로저 : 부모함수안에 자식함수는 부모함수의 실행이 끝나도 부모함수의 변수를 가져다 쓸 쑤 있다.(바깥 스코프에 있는 변수를 가져다 사용하는 함수), 함수에서 변수가 저장되는 장소도 또한 클로저라고 불리운다. 
* 클로저를 이용해 데이터를 숨기고 정해진 방법을 통해서만 데이터에 접근할 수 있도록 제한을 둘 때도 사용된다.
* 간단한 고차 함수는 화살표 함수로 쓰기도 한다. 
* ++나 --의 위치에 따라 반환값이 다르다. (x++ -> 1 / ++x -> 2)
* 재귀함수를 이용해서 문제를 같은 형태의 부분문제로 쪼갤 수 있을 때, 활용할 수 있다.
* ex.
```js
sb(5) = 1 + 2 + 3 + 4 + 5 = sb(4) + 5
```
* 재귀함수를 이용한 피보나치 수열 구하기
```js
function fiboRec(n) {
  if(n===0) {
    return 0
  } else if (n === 1) {
    return 1
  } else {
    return fiboRec(n - 2) + fiboRec(n - 1)
  }
}

fiboRec(5)
```
* 재귀함수를 작성할 때 부분문제, 종료조건 생각하기
* property descriptor(getOwnPropertyDescriptor을 사용해 객체의 속성의 성질을 알 수 있다.)
* 어떤 객체의 전체 속성에 대한 속성 기술자를 얻어오려면, Object.getOwnPropertyDescriptors 정적 메소드를 사용하면 된다.
* 엄격 모드가 아닐 때에는 writable: false, configurable: false인 속성을 변경하거나 삭제하려고 해도 에러가 나지 않고 그냥 무시되지만, 엄격 모드일 때에는 에러가 발생한다.
* 직접 속성 기술자를 가지고 속성을 정의할 수도 있다.
* Object.defineProperty나 Object.defineProperties를 이용해서 객체에 대한 속성을 직접 정의할 수도 있다. 
* getter and setter
* getter는 속성을 읽어오기만해도 get으로 지정된 메소드가 실행된다.
* setter는 속성의 값을 변경할 때 set으로 지정된 메소드가 실행된다.
* 속성에 접근하기만 해도 함수를 호출 할 수도 있다.
* Object.keys, Object.values, Object.entries (객체 자신의 속성 중 열거 가능한(enumerable) 속성만 반환)
* object.keys에서 객체 속성들은 랜덤한 순서로 출력된다. 
* 객체를 복사할 때는 object.assign을 많이 사용한다. (사실 객체에 대한 참조를 복사한 것이다.) 
* 내부에 있는 객체는 object.assign을 통해 복사되지 않는다.
* 중첩되어있는 자료구조는 복사되지 않는다. (겉만 복사될 뿐 안에있는 원본이 바뀔 수 있다.) 
* 중첩되어있는 자료구조까지 복사하고 싶은경우 다른 방법을 써야한다. 
* 깊은 복사를 위한 함수는 재귀함수를 사용해야 하며 라이브러리 사용을 추천
* 