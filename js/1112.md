# 수업메모
* 횡단관심사(cross-cutting concerns) : 여러 부분에 걸쳐 적용되어야하는 부분(로그인, 레이아웃, 로딩인디케이터 등 
* 오늘 고차함수와 불변성, 그냥 함수와 화살표함수에서의 this 차이점 꼭 공부하기
* 라이브러리를 쓰기위해서 기본적으로 DOM API에 대한 지식이 있어야 한다.
* 프로그래밍의 두가지 갈래
  * 명령형 (세부적인 컨트롤이 가능하나 결과물의 최종적인 구조를 확인하기가 힘들다. 즉 처음부터 끝까지 다 완성해야 코드를 알 수 있다.)
  ex. DOM API
  * 선언적 (코드가 생겨지는데로 결과물이 나온다. 즉 코드가 결과물의 구조를 잘 반영하고있다.)
  ex. HTML

## 리액트
* 리액트에서 컴포넌트는 클래스고 UI를 반환하는 메소드(render)를 가지고있다.
* 뷰 : 어떻게 그릴것인지 설명하는 값
* 리액트에서 div, h1, ul등의 태그는 모두 객체이며 값이다. 
* 요소안에 텍스트컨텐트를 넣어주고 싶을때는 {}를 사용
* 리액트에서 class를 쓸때는 className으로 써준다.
* 컴포넌트와 엘리먼트의 차이점 알아두기
* 하나의 컴포넌트에서 다른 컴포넌트로 데이터를 넘겨줄 수 있다.
* prop은 부모로부터 값을 내려받는 통로 (부모로부터 자식)
* 리액트 엘리먼트의 어트리뷰트를 적어주면 그것은 props 객체의 속성이 된다.
* prop을 넘김으로써 부모로부터 자식에게 정보가 흐른다. (위에서 아래로)
* 리액트 이벤트리스너 : onClick, onSubmit onMove etc...
* onClick같이 함수를 넘겨주는 prop에는 꼭 값이 아닌 함수를 넣어준다.
* super는 부모클래스의 생성자를 호출하는 코드
* 리액트 컴포넌트의 생성자를 정해줘야 할 때는 무조건 super(props)가 반드시 존재해야 한다.
* props와 다르게 state는 내가 가지는 값을 기억한다.
* this.state는 객체(리터럴)을 항상 포함하고 있어야 한다.
* this.setState는 state의 내용을 바꿔주며 자동적으로 화면을 다시 그린다. (state의 내용을 바꿔줄때는 꼭 setState를 사용해야 한다.)
* 리액트에서는 화면을 다시 그려주기 위해서는 상태를 바꾸는 방법밖에는 없다.
* 리액트는 화면을 다시 그려야 할 때마다 컴포넌트의 render()메소드를 호출한다.
* render안에서 화면을 그리는 일과 상관 없는코드 예를들어 변수의 상태변경이나 통신코드가 있으면 절대 안된다.
* 또한 한 컴포넌트가 다시 그려지게 되면 밑에있는 자식 컴포넌트까지 다시 그려진다. 즉 해당되는 컴포넌트들의 render()메소드들이 다 호출된다.
* 자식 컴포넌트의 상태를 부모 컴포넌트에서 읽어올 수 없다.
* 상태를 공유해야하는 컴포넌트들의 가장 가까운 공동조상에 상태를 두는것이 원칙이다.
* 소스의 불일치를 피하기 위해 상태는 하나에만 저장하는 것이 좋다.
* 만약 부모에서 상태를 바꾸는 함수를 자식에게 전달하면 자식에게 전해준다면 간접적으로 부모의 상태를 바꿀 수 있다.
* button -> 리액트에 내장된 DOM 컴포넌트 / Square 함수 -> 커스텀 컴포넌트
* 자기 스스로 무엇인가 할 수 없는 컴포넌트 : 제어되는 컴포넌트
* 컴포넌트는 클래스와 함수형 두가지가 있다.
* 함수형 컴포넌트에서 부모로부터 내려받은 값은 함수의의 속성에 저장된다.
* 리액트 생성자 만들때 constructor props와 super props 기억하기
* 리액트 코딩순서
  * 화면을 먼저 그려보기
  * 상태를 설계하기 (무엇을 기억해야할지)
  * 상태로부터 화면을 그리는 코드쓰기
  * 상태를 변경하는 코드쓰기 
