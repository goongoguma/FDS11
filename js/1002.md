# 수업메모
* 객체에서 이름과 값(key, value pair)은 속성으로 불리운다.
* 중괄호를 써서 객체를 표현하는 표기법 -> 객체 리터럴
* 식별자는 객체 속성의 이름으로 사용되어질 수 있다. 또한 식별자 규칙을 만족하는 속성 이름을 사용할 때는 따옴표를 생략해도 된다.
* 객체 리터럴에서 속성 값이 와야하는 부분에 어떠한 표현이 와도 상관이 없다. 
* 객체 리터럴에서 단축표기법 사용가능 
* 객체 리터럴 안에서 대괄호 내부의 표현식의 결과값이 속성 이름으로 사용 될 수 있다. 
```js
const propName = 'prop';

const obj = {
  [propName]: 1
};

obj.prop; // 1
```
* 사용자가 입력한 내용을 속성이름을 입력할경우 즉 속성의 이름을 모를 경우를 위해 객체 이름 표기법이 여러 종류가 있는 것
* 속성 접근자에서 .표기법은 식별자 규칙을 만족하는 경우에만 사용이 가능하다. 규칙을 만족하지 않는 경우에와 사용자로부터 입력받은 값을 속성이름으로 사용할경우 대괄호 표기법을 사용해야 한다.
```js
const propName = prompt('속성 이름을 입력하세요')
const propValue = prompt('속성 값을 입력하세요')

const obj = {}
obj[propName] = propValue
```
* 문자열이 그대로 속성이름으로 사용되는지 아니면 표현식의 결과값이 속성이름으로 사용되는지 잘 알아두어야 한다.
* 속성은 delete으로 삭제 가능하다.
```js
delete person.address;
```
* 속성이 객체안에 있는지는 in으로 확인이 가능하다. (in도 연산자임)
```js
'name' in person; // true
'phoneNumber' in person; // false
```
* 어떤 객체의 속성으로 접근해서 사용하는 함수를 메소드(method)라고 하며 축약표기법 사용이 가능하다.
* 생성자를 통해 생성된 객체를 그 생성자의 인스턴스라고 하며 instanceof를 사용하여 확인 할 수 있다.
* 객체 리터럴을 통해 생성된 객체는 Object의 인스턴스입니다. 
* 생성자와 일반적인 함수와의 차이는 없다. 앞글자를 대문자로 표기하는거 제외
* 객체와 배열의 차이점은 배열에는 각 요소간의 순서가 있다는 것
* 배열은 Array 생성자 함수의 인스턴스이다.
* Array 생성자 함수는 주어지는 인수에 따라 다른 방식으로 동작한기 때문에 Array.of가 나왔다
* Array.from을 사용해서 split과 같은 효과를 줄 수 있다. (문자열 하나하나씩 분리)
* pop 메소드는 배열의 맨 마지막 요소를 반환하기도 한다.
* 배열의 특정 인덱스에 (요소를 삭제하고) 새로운 요소를 넣기 위해서는 splice 메서드 사용을하는게 좋다. 또한 교체된 부분 배열을 반환하는 것도 가능
* sort 메서드를 사용할 때 비교함수를 꼭 써주기. 안써주게되면 요소를 문자열로 변환한 뒤에 유니코드코드 포인트를 비교하는 방식으로 정렬한다.
* localeCompare() 메서드로 사전순으로 비교가 가능 
* for...of 구문 연습해보기
* for...of 구문으로 배열을 돌게되면 한번 돌때마다 변수를 선언하며 블록스코프를 생성한다.
* 원본배열을 바꾸는 메서드 vs 배열을 바꾸지않는 메서드
* arr.slice() === arr.slice(0, arr.length)
* 원본배열을 바꾸는 메서드를 사용할 경우 배열을 바꾸지 않는 메서드를 이용해 원본을 복사한 복사본을 사용한다.(slice)
* let과 const의 차이는 재대입이 가능한지 못한지의 차이